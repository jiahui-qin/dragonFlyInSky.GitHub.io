---
title: redis能不能作为消息队列？
date: 2021-04-22 19:00:38
tags:
- 转载
categories:
- 指南
---

昨天晚上睡觉之前看到一篇我觉得很好的文章，文章标题是[把 Redis 当作队列来用，真的合适吗？](https://mp.weixin.qq.com/s/QQTG7RIOgSvSIueTqOHwww)

读完之后感觉好像写的很好，我在这里大致总结一下，主要有以下几个总结点

1. 消息队列用来做什么？
2. 用redis来做消息队列有什么方法？
3. 为什么用redis来做消息队列/不做消息队列？
4. 关于这一点的思考

<!--more-->
---
## 消息队列是用来做什么的？

消息队列是一个存放消息的容器，需要使用消息时可以取出消息供使用，有以下几个好处：

* 异步处理提高系统性能，削峰
* 降低系统耦合性

常用的消息队列有 kafka, activeMQ, rabbitMQ, rocketMQ

消息队列类似与先进先出的queue数据结构，在消息队列中我们可能需要考虑以下问题：

* 消息是否有可能被重复消费？
* 消息是否有可能丢失？：在生产者处丢失、在传输过程中丢失、消费者处丢失
* 多消费者的情况下如何保证每个消费者都消费到了消息？
* 消费顺序如何保证正确？
 ······

可见引入消息队列也会使得系统可用性降低、复杂性提高、一致性处理复杂····

redis是一个内存数据库，在某种程度上也可以用来做消息队列，接下来我们详细见讲一讲

## redis怎么做消息队列？

### 最简单的方法 List

List是redis中的一个数据类型，底层实现是一个列表，直接如下操作就可以当作消息队列：

    ## 生产者发布消息：
    127.0.0.1:6379> LPUSH queue msg1
    (integer) 1
    127.0.0.1:6379> LPUSH queue msg2
    (integer) 2

    消费者这一侧，使用 RPOP 拉取消息：
    127.0.0.1:6379> RPOP queue
    "msg1"
    127.0.0.1:6379> RPOP queue
    "msg2"

这么做非常好理解，一个放数据进来，一个取数据，但是会带来什么问题呢？

没有一个消息提醒机制来告诉我们有消息进来了，所以我们需要在消费者处写一个死循环，不断的从队列中拉取数据：

    while true:
        msg = redis.rpop("queue")
        // 没有消息，继续循环
        if msg == null:
            continue
        // 处理消息
        handle(msg)

如果没有数据，那么就会造成CPU空转，如果不想要CPU空转，那就要写一个休眠时间，每隔固定时间去请求数据。这样又会引入新的问题：休眠时来消息，会造成处理消息延迟。也就是说，消息延迟和CPU空转二者是一个鱼与熊掌不可兼得的问题。

### 更高端的方式 BRPOP/BLPOP

如果队列为空，消费者就处于阻塞状态等待，有新消息过来，就通知消费者进行处理。

    while true:
        // 没消息阻塞等待，0表示不设置超时时间
        msg = redis.brpop("queue", 0)
        if msg == null:
            continue
        // 处理消息
        handle(msg)

这样就避免了上边的问题，但是缺点呢：不支持重复消费->不支持多个消费者消费同一批数据， 消息可能会丢失（无法重新消费）

### 发布/订阅模型 pub/sub

这种模型可以解决一个问题：重复订阅



